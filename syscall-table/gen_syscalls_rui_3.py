import ctags, re, simplejson, sys, os
from ctags import CTags, TagEntry

# file generated by ctags --fields=afmikKlnsStz --c-kinds=+pc -R
tags = CTags('tags')
entry = TagEntry()

sct_file = open('arch/x86/kernel/syscall_table_32.S', 'r')

sys_calls = []
i = 0

for line in sct_file:
	name = re.search(".long (\w*)", line)
	if(name):
		name = name.group(1)
		is_ptregs = False
		if(name == "sys_ni_syscall"):
			#sys_calls.append([i, "not implemented", "", "%0#4x"%(i), "", "", "", "", "", "", ""])
			print '{ ' + repr(i) + ', "", "not implemented", 0, "", "", "", "", "", "", "" },'
			i += 1
			continue
		# take care of ptregs
		elif(name.find('ptregs_') == 0):
			name = name.replace("ptregs_", "sys_")
			is_ptregs = True
		# use the sys_chmod to locate the prototype
		if tags.find(entry, name, ctags.TAG_FULLMATCH | ctags.TAG_OBSERVECASE):
			found_sym = False
			while(not found_sym):
				if(entry['kind'] == 'prototype'): # locate the prototype
					found_sym = True	
					args = entry['signature'].strip('()').strip(')').split(',')# get the arguments
					# grab the return type here
					if(entry['pattern'].find('asmlinkage') != -1):
						ret = entry['pattern'].split(' ')[1]
						#print entry['pattern'].split(' ')[1]
					else:		
						ret = entry['pattern'].split(' ')[0].strip('/^')				
						#print entry['pattern'].split(' ')[0].strip('/^')

					details = [i, ret, name, len(args)]
					for y in range(0, len(args)):
						if "*" in args[y]:
							args[y] = re.sub(r'([*?])(\w+)\b', '*', args[y]) #replace *lvec with *
						else:
							args[y] = args[y].rsplit(' ', 1)[0]
						details.append(args[y])	# here remove the virable name only keep the type info.		
					remaining = 11 - len(details)
					for x in range(0, remaining):
						details.append("")
					#print details
					if(entry['signature'] != "(void)"):
						sig = entry['signature'].strip('()').split(',')
					else:
						sig = []
						details[3] = 0
						details[4] = "" # dealwith the no argument case, see 
					#regs = {};
					#above code generate enough.

					#try to get the line now
					if(not is_ptregs):
						pattern = "SYSCALL_DEFINE%d(%s"%(len(sig), name.replace("sys_", ""))
						search = "SYSCALL_DEFINE%d"%(len(sig))
					else:
						pattern = name
						search = name

					if tags.find(entry, search, ctags.TAG_FULLMATCH | ctags.TAG_OBSERVECASE):
						found = False
						while(found == False):
							if(entry['pattern'].find(pattern) == 2):
								#details['found'] = entry['pattern']
								#details.append(entry['file'])
								#details.append(int(entry['lineNumber']))
								found = True
								break
							if(not tags.findNext(entry)):
								#details.append("not found")
								#details.append("")
								break
					#else:
						#details.append("not found")
						#details.append("")
					print "{ %s }," % (", ".join(repr(e) for e in details )).replace("'", "\"");
					#print type(entry)
					
					#sys_calls.append(details)
				else:
					if(not tags.findNext(entry)):
						#sys_calls.append([i, "", "", "", "", "", "", "", "", "", ""])
						#print 'findNext void'
						break
		i += 1

#print simplejson.dumps({'aaData': sys_calls}, indent="   ")
